module Snake_ctrl_module
//蛇运动情况控制模块
(
	input Clk_50mhz,
	input Rst_n,
	
	input Key_left,
	input Key_right,
	input Key_up,
	input Key_down,
	
	output reg [1:0] Object,//用于表示当前扫描的部件 四种状态 00：无 01：头 10：身体 11：墙
									//也用于后面的VGA，通过Object来判断颜色的输出
	input [9:0] Pixel_x,//低4位表示一个格子内像素的坐标，高5位表示格坐标
	input [9:0] Pixel_y,//扫描坐标  单位：“像素点”
	
	output [5:0] Head_x,	//头部那一格的X坐标
	output [5:0] Head_y,//头部那一格的Y坐标
	
	input Body_add_sig,//身体长度增加信号
	
	input [1:0] Game_status,//四种游戏状态

	
	output reg [6:0] Body_num,
	
	output reg Hit_body_sig,
	output reg Hit_wall_sig,
	input Flash_sig
);
/***************************************************************************/
	
	localparam Up = 2'b00;
	localparam Down = 2'b01;
	localparam Left = 2'b10;
	localparam Right = 2'b11;
	
	
	localparam NONE = 2'b00;
	localparam HEAD = 2'b01;
	localparam BODY = 2'b10;
	localparam WALL = 2'b11;
	
	localparam PLAY = 2'b10;
	
/***************************************************************************/
/***************************************************************************/
	reg [31:0] Count;
	
	wire [1:0] Direct;
	reg [1:0] Direct_r;
	
	assign Direct = Direct_r;
	
	reg [1:0] Direct_next;
	
	reg Direct_left;
	reg Direct_right;
	reg Direct_up;
	reg Direct_down;
	
	reg [5:0] Body_x [15:0];//这种格式是二维数组的意思，地址为0~15，每个地址为6bits
	reg [5:0] Body_y [15:0];//体长坐标 单位：“格子” ，16*16像素组成的格子
	reg [15:0] Snake_light_sig;//这用来控制蛇体亮暗，1为亮，0为暗
	
	reg [2:0] color;//RGB三个位
	
	assign Head_x = Body_x[0];//Body_x，Body_y表示一整条大蟒蛇身体各节的格坐标

	assign Head_y = Body_y[0];
	//cube[0]表示head这个格，（就是上面蓝色的头部）head是我们主要要控制的地方，它涉及到END .EattingApple.
	//还有身体运动轨迹等……所以head单独提取出来作为输出信号Head_x和Head_y用于后面的模块。

/***************************************************************************/
	
	always@(posedge Clk_50mhz or negedge Rst_n)
	begin
		if(!Rst_n)
			Direct_r <= Right;//默认一出来就是向右前进
		else
			Direct_r <= Direct_next;
	end
	
/***************************************************************************/
/***************************************************************************/
	
	always@(posedge Clk_50mhz or negedge Rst_n)
	begin
		if(!Rst_n)
			begin
				Count <= 0;
				//X从左到右递增，Y从上到下递增
				Body_x[0] <= 10;//蛇头默认出现的X坐标是10
				Body_y[0] <= 5;//蛇头默认出现的Y坐标是5
				
				Body_x[1] <= 9;//第一节身体的X坐标是9
				Body_y[1] <= 5;//第一节身体的Y坐标还是5
				
				Body_x[2] <= 8;//第二节身体的X坐标是8
				Body_y[2] <= 5;//第二节身体的Y坐标还是5
				
				
				//后面的身体暂时还没有，所以没有所谓的坐标，都为0，最多是16节身体
				Body_x[3] <= 0;
				Body_y[3] <= 0;
				
				Body_x[4] <= 0;
				Body_y[4] <= 0;
				
				Body_x[5] <= 0;
				Body_y[5] <= 0;
				
				Body_x[6] <= 0;
				Body_y[6] <= 0;
				
				Body_x[7] <= 0;
				Body_y[7] <= 0;
				
				Body_x[8] <= 0;
				Body_y[8] <= 0;
				
				Body_x[9] <= 0;
				Body_y[9] <= 0;
				
				Body_x[10] <= 0;
				Body_y[10] <= 0;
				
				Body_x[11] <= 0;
				Body_y[11] <= 0;
				
				Body_x[12] <= 0;
				Body_y[12] <= 0;
				
				Body_x[13] <= 0;
				Body_y[13] <= 0;
				
				Body_x[14] <= 0;
				Body_y[14] <= 0;
				
				Body_x[15] <= 0;
				Body_y[15] <= 0;
				
				
				Hit_wall_sig <= 0;
				
				Hit_body_sig <= 0;
			end
		else
			begin//这里强调一下，begin end里面的语句是顺序执行的
				Count <= Count + 1;//这里用一个ELSE放到后面去
				
				if(Count == 12_500_000) //0.02us*12'500'000 = 0.25s   每秒移动四次
					begin
						Count <= 0;
						
						if(Game_status == PLAY)
							begin
							//撞墙有四种情况，上下左右，撞到上，Y = 1；撞到下边，Y = 28；撞到左边，X = 1；撞到右边，X = 38；画个图就知道了~
								if((Direct == Up&&Body_y[0] == 1)|(Direct == Down&&Body_y[0] == 28)|(Direct == Left&&Body_x[0] == 1)|(Direct == Right&&Body_x[0] == 38))
									Hit_wall_sig <= 1;
								
								else if((Body_y[0] == Body_y[1]&&Body_x[0] == Body_x[1]&&Snake_light_sig[1] == 1)|
										(Body_y[0] == Body_y[2]&&Body_x[0] == Body_x[2]&&Snake_light_sig[2] == 1)|
										(Body_y[0] == Body_y[3]&&Body_x[0] == Body_x[3]&&Snake_light_sig[3] == 1)|
										(Body_y[0] == Body_y[4]&&Body_x[0] == Body_x[4]&&Snake_light_sig[4] == 1)|
										(Body_y[0] == Body_y[5]&&Body_x[0] == Body_x[5]&&Snake_light_sig[5] == 1)|
										(Body_y[0] == Body_y[6]&&Body_x[0] == Body_x[6]&&Snake_light_sig[6] == 1)|
										(Body_y[0] == Body_y[7]&&Body_x[0] == Body_x[7]&&Snake_light_sig[7] == 1)|
										(Body_y[0] == Body_y[8]&&Body_x[0] == Body_x[8]&&Snake_light_sig[8] == 1)|
										(Body_y[0] == Body_y[9]&&Body_x[0] == Body_x[9]&&Snake_light_sig[9] == 1)|
										(Body_y[0] == Body_y[10]&&Body_x[0] == Body_x[10]&&Snake_light_sig[10] == 1)|
										(Body_y[0] == Body_y[11]&&Body_x[0] == Body_x[11]&&Snake_light_sig[11] == 1)|
										(Body_y[0] == Body_y[12]&&Body_x[0] == Body_x[12]&&Snake_light_sig[12] == 1)|
										(Body_y[0] == Body_y[13]&&Body_x[0] == Body_x[13]&&Snake_light_sig[13] == 1)|
										(Body_y[0] == Body_y[14]&&Body_x[0] == Body_x[14]&&Snake_light_sig[14] == 1)|
										(Body_y[0] == Body_y[15]&&Body_x[0] == Body_x[15]&&Snake_light_sig[15] == 1))
										
										Hit_body_sig <= 1;//头的Y坐标 = 任一位身体的Y坐标 且 头的X坐标 = 任一位身体的X坐标 且 身体的该长度位存在  碰到身体
								else
									 begin//下面的代码是产生跟随现象，后面一节身体跟着前面一节身体的地址~
										Body_x[1] <= Body_x[0];
										Body_y[1] <= Body_y[0];
										
										Body_x[2] <= Body_x[1];
										Body_y[2] <= Body_y[1];
										
										Body_x[3] <= Body_x[2];
										Body_y[3] <= Body_y[2];
										
										Body_x[4] <= Body_x[3];
										Body_y[4] <= Body_y[3];
										
										Body_x[5] <= Body_x[4];
										Body_y[5] <= Body_y[4];
										
										Body_x[6] <= Body_x[5];
										Body_y[6] <= Body_y[5];
										
										Body_x[7] <= Body_x[6];
										Body_y[7] <= Body_y[6];
										
										Body_x[8] <= Body_x[7];
										Body_y[8] <= Body_y[7];
										
										Body_x[9] <= Body_x[8];
										Body_y[9] <= Body_y[8];
										
										Body_x[10] <= Body_x[9];
										Body_y[10] <= Body_y[9];
										
										Body_x[11] <= Body_x[10];
										Body_y[11] <= Body_y[10];
										
										Body_x[12] <= Body_x[11];
										Body_y[12] <= Body_y[11];
										
										Body_x[13] <= Body_x[12];
										Body_y[13] <= Body_y[12];
										
										Body_x[14] <= Body_x[13];
										Body_y[14] <= Body_y[13];
										
										Body_x[15] <= Body_x[14];
										Body_y[15] <= Body_y[14];
										//身体运动算法 本长度位移动的下个坐标为下一个长度位当前坐标 运动节拍按分频后的节奏
										case(Direct)//这里选择的是按键，在墙边的时候							
											Up:
												begin
													if(Body_y[0] == 1)
														Hit_wall_sig <= 1;
													else
														Body_y[0] <= Body_y[0] - 6'd1;//注意坐标系，这里是 - 1，因为最上面是0，所以向上走的话，Y是 - 1的。
												end
											
											Down:
												begin
													if(Body_y[0] == 28)
														Hit_wall_sig <= 1;
													else
														Body_y[0] <= Body_y[0] + 6'd1;
												end
											Left:
												begin
													if(Body_x[0] == 1)
														Hit_wall_sig <= 1;
													else
														Body_x[0] <= Body_x[0] - 6'd1;//注意坐标系，这里是 + 1，因为最左面是0，所以向左走的话，X是 - 1的。	
												end
											
											Right:
												begin
													if(Body_x[0] == 38)
														Hit_wall_sig <= 1;
													else
														Body_x[0] <= Body_x[0] + 6'd1;
														//根据按下按键判断是否撞墙 否则按规律改变头部坐标
												end
										endcase																	
									 end					
							end
					end 
			end 
	end
/***************************************************************************/
	
	always@(posedge Clk_50mhz)//给四个按键赋值
	begin
		if(Key_left == 1)
				Direct_left <= 1;
		else if(Key_right == 1)
				Direct_right <= 1;
		else if(Key_up == 1)
				Direct_up <= 1;
		else if(Key_down == 1)
				Direct_down <= 1;			
		else 
			begin
				Direct_left <= 0;
				Direct_right <= 0;
				Direct_up <= 0;
				Direct_down <= 0;
			end
	end
	/***************************************************************************/
	
	always@(*)//这里也是电平触发
	begin   //根据当前运动状态即按下键位判断下一步运动情况，不在墙边的情况
		Direct_next = Direct;
		
		case(Direct)
			Up://根据按键进行三个方向的选择，这里是按键按下的时候，信号传导Direct_next，然后由Direct_next送给Direct_r，最后再赋值给Direct
				begin
					if(Direct_left)
						Direct_next = Left;
					else if(Direct_right)
						Direct_next = Right;
					else
						Direct_next = Up;
				end
			
			Down:
				begin
					if(Direct_left)
						Direct_next = Left;
					else if(Direct_right)
						Direct_next = Right;
					else
						Direct_next = Down;
				end		
			Left:
				begin
					if(Direct_up)
						Direct_next = Up;
					else if(Direct_down)
						Direct_next = Down;
					else
						Direct_next = Left;
				end
			
			Right:
				begin
					if(Direct_up)
						Direct_next = Up;
					else if(Direct_down)
						Direct_next = Down;
					else
						Direct_next = Right;
				end		
		endcase
	end

/***************************************************************************/
	reg Eaten_sig;//吃苹果状态
	
	always@(posedge Clk_50mhz or negedge Rst_n)//吃下苹果没？，吃下则Body_add_sig == 1，显示体长增加一位，"is_exixt[Body_num] <= 1",让第Body_num位“出现”
		begin
			if(!Rst_n)
				begin
					Snake_light_sig <= 16'd7;//0111
					Body_num <= 3;
					Eaten_sig <= 0;//初始显示长度为3，Snake_light_sig = 0000_0000_0111
				end		
		   else 
				begin//判断蛇头与苹果坐标重合
					case(Eaten_sig)
						0:
							begin
								if(Body_add_sig)
									begin
										Body_num <= Body_num + 7'd1;
										Snake_light_sig[Body_num] <= 1;
										Eaten_sig <= 1;//“吃下”信号
									end
								else
									begin
										Body_num <= Body_num;
										Snake_light_sig[Body_num] <= Snake_light_sig[Body_num];
										Eaten_sig <= Eaten_sig;
									end 
						   end
						1:
							begin
								if(!Body_add_sig)//Body_add_sig哪里改变了
									Eaten_sig <= 0;
								else
									Eaten_sig <= Eaten_sig;
						   end
					endcase
			   end
		end
	
	reg [3:0] lox;
	reg [3:0] loy;
	
	always@(Pixel_x or Pixel_y or Snake_light_sig or Flash_sig)//注意，这里是电平触发，所以用的是阻塞赋值“=”
		begin
			if(Pixel_x >= 0&&Pixel_x<640&&Pixel_y >= 0&&Pixel_y<480)
				begin
					if(Pixel_x[9:4] == 0|Pixel_y[9:4] == 0|Pixel_x[9:4] == 39|Pixel_y[9:4] == 29)
						Object = WALL;//扫描墙
					else if(Pixel_x[9:4] == Body_x[0]&&Pixel_y[9:4] == Body_y[0]&&Snake_light_sig[0] == 1)//扫描头
							Object = (Flash_sig == 1)?HEAD:NONE;//
					else if((Pixel_x[9:4] == Body_x[1]&&Pixel_y[9:4] == Body_y[1]&&Snake_light_sig[1] == 1)|
							 (Pixel_x[9:4] == Body_x[2]&&Pixel_y[9:4] == Body_y[2]&&Snake_light_sig[2] == 1)|
							 (Pixel_x[9:4] == Body_x[3]&&Pixel_y[9:4] == Body_y[3]&&Snake_light_sig[3] == 1)|
							 (Pixel_x[9:4] == Body_x[4]&&Pixel_y[9:4] == Body_y[4]&&Snake_light_sig[4] == 1)|
							 (Pixel_x[9:4] == Body_x[5]&&Pixel_y[9:4] == Body_y[5]&&Snake_light_sig[5] == 1)|
							 (Pixel_x[9:4] == Body_x[6]&&Pixel_y[9:4] == Body_y[6]&&Snake_light_sig[6] == 1)|
							 (Pixel_x[9:4] == Body_x[7]&&Pixel_y[9:4] == Body_y[7]&&Snake_light_sig[7] == 1)|
							 (Pixel_x[9:4] == Body_x[8]&&Pixel_y[9:4] == Body_y[8]&&Snake_light_sig[8] == 1)|
							 (Pixel_x[9:4] == Body_x[9]&&Pixel_y[9:4] == Body_y[9]&&Snake_light_sig[9] == 1)|
							 (Pixel_x[9:4] == Body_x[10]&&Pixel_y[9:4] == Body_y[10]&&Snake_light_sig[10] == 1)|
							 (Pixel_x[9:4] == Body_x[11]&&Pixel_y[9:4] == Body_y[11]&&Snake_light_sig[11] == 1)|
							 (Pixel_x[9:4] == Body_x[12]&&Pixel_y[9:4] == Body_y[12]&&Snake_light_sig[12] == 1)|
							 (Pixel_x[9:4] == Body_x[13]&&Pixel_y[9:4] == Body_y[13]&&Snake_light_sig[13] == 1)|
							 (Pixel_x[9:4] == Body_x[14]&&Pixel_y[9:4] == Body_y[14]&&Snake_light_sig[14] == 1)|
							 (Pixel_x[9:4] == Body_x[15]&&Pixel_y[9:4] == Body_y[15]&&Snake_light_sig[15] == 1))
													
							Object = (Flash_sig == 1)?BODY:NONE;//扫描身体
					else 
							Object = NONE;
				end
			else
			Object = NONE;
		end
	
endmodule
